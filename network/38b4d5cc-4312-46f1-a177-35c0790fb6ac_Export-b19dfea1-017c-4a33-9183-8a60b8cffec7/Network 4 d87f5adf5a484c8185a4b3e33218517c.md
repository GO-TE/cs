# Network 4.

---

# 전송 계층

전송계층은 OSI 7계층에서 네트워크와 응용 계층 사이에 있음

전송 계층은 신뢰할 수 있는 통신과 연결형 통신을 가능하게 함

→ IP의 한계 극복, 포트 번호를 통해 응용 계층의 애플리케이션 프로세스를 식별함

### 신뢰할 수 없는 통신과 비연결형 통신

**IP**는 신뢰가 없고 연결 하는 과정이 없는 프로토콜임

`신뢰할수 없는 통신` : 패킷이 수신지까지 제대로 전송되었는지 보장을 안함

`비연결형 통신` : 송수신 호스트 간에 사전 연결 수립 작업을 거치치 않음

빠른 성능을 위해 IP는 이러한 특징을 택했다고 함

### 전송 계층의 보완

1. 전송 계층은 연결형 통신을 지원
    
    `TCP` : 전송 계층의 연결형 프로토콜 
    
    패킷이 수신지까지 올바른 순서대로 확실히 가도록 보장하기 위해 재전송을 통한 오류, 흐름, 혼잡 제어 등을 수행 함
    
2. 신뢰성 있는 통신 가능
    
    마찬가지로 TCP를 통해 지원
    
    `UDP` : 신뢰할 수 없는 통신, 비연결형 통신을 가능하게 하는 전송 계층의 프로토콜
    
    TCP는 하는 일이 많아서 느릴 수 있음 근데, 딱히 저런 역할이 필요 없는 경우도 있음
    
    그럴 때 UDP를 쓴다. 예를 들면 치지직같이 실시간 스트리밍이라면 패킷이 한두개정도 손실되도 괜찮음
    

### 포트

`포트` : 특정 애플리케이션이 패킷을 전달받기 위한 식별 정보

라우팅되서 호스트가 패킷을 받은게 끝이 아니라 프로세스에 전달되서 데이터를 처리해야 의미 있지 않을까?

TCP와 UDP는 포트 번호를 포함하고, 포트 번호는 16비트로 0~65535까지 가능

| 종류 | 범위 |
| --- | --- |
| 잘 알려진 포트 | 0~1023 |
| 등록된 포트 | 1024~49151 |
| 동적 포트 | 49152~65535 |
- Well Known Port
    
    시스템 포트라고도 함. 국룰 포트라고 보면 편함
    
    | port number | description |
    | --- | --- |
    | 20, 21 | FTP |
    | 22 | SSH |
    | 23 | TELNET |
    | 53 | DNS |
    | 67, 68 | DHCP |
    | 80 | HTTP |
    | 443 | HTTPS |
- registered port
    
    덜 범용적인데, 흔히 사용되는 애플리케이션에 할당하기 위해 사용
    
- dynamic port
    
    인터넷 할당 번호 관리 기관에 의해 할당된 애플리케이션 프로토콜이 없고 특별히 관리 되지 않아 자유롭게 사용 가능
    

서버로 동작하는 프로그램은 일반적으로 포트가 암묵적으로 정해져있음

클라이언트가 동작하는 프로그램은 포드번호가 임의인 경우가 많음

이렇게 서로 포트 번호로 패킷을 송수신함

`IP주소 : 포트 번호` 형식으로 표기됨

### 포트 기반 NAT

`NAT` : IP 주소를 변환하는 기술 : 네트워크 내부 사설 IP를 외부 공인 IP로 변환

`NAT 변환 테이블` : NAT로 바꾼 IP를 저장한 테이블

![image.png](Network%204%20d87f5adf5a484c8185a4b3e33218517c/image.png)

| 네트워크 외부 | 네트워크 내부 |
| --- | --- |
| 1.2.3.4 | 192.168.0.5 |

NAT 변환 테이블이 위처럼 있다면

네트워크 외부에서 1.2.3.4에 송신을 함 → 라우터가 변환해서 192.168.0.5로 변환

근데 공인 IP와 사설 IP는 1:1로 대응하지 않음 (사설 IP만큼 공인 IP도 많이 필요해서…)

1:N으로 가능하도록 하는게 포트임

### NAPT

포트 기반의 NAT를 NAPT라고 함

위에서 언급했듯, `IP : 포트` 이 방식으로 NAT 테이블을 관리해서 한 아이피로 여러 사설 아이피가 쓸 수 있도록 함

### 포트포워딩

네트워크 내 특정 호스트에 IP 주소와 포트 번호를 미리 배정하고 해당 IP:포트로 해당 호스트에서 패킷을 전달하는 기술

외부에서 통신을 할 때, 해당 IP와 포트 번호로 통신할 수 있도록 해줌

### ICMP

IP 패킷의 전송 과정에 대한 피드백 메세지를 얻기 위해 쓰는 프로토콜

[전송 과정 문제 오류 리포팅, 네트워크 진단 정보] 로 구성되어 있음

## TCP

Transmission Control Protocol

위에 언급했듯이, 신뢰할 수 있는 통신을 위한 연결형 프로토콜

### TCP 통신 단계

연결 수립 → 데이터 송수신 → 연결 종료

### TCP 세그먼트

`MMS` : Maximum Segment Size, TCP로 전송할 수 있는 최대 페이로드 크기

[이더넷 헤더, IP 헤더, TCP 헤더, 페이로드, FCS]

![정보통신기술용어해설](Network%204%20d87f5adf5a484c8185a4b3e33218517c/image%201.png)

정보통신기술용어해설

Sequence Number : 순서 번호가 명시되는 필드 : 순서 번호 - 세그먼트의 순서를 위함

Acknowledgement number : 상대 호스트가 보낸 세그먼트에 대한 응답 : 다음 수신을 위한 순서 번호가 명시

제어 비트 (예약과 윈도우 사이즈 사이) : 현재 세그먼트에 대한 부가 정보

윈도우 사이즈 : 수신 윈도우의 크기가 명시 : 수신 윈도우 - 한 번에 수신 되는 데이터 양

> **제어 비트**
> 
> 
> 기본적으로 8비트임, 1이면 해당 속성임을 알림
> 
> ex) 00000001 : 종료임을 알리는 비트
> 
> **CWR** : Congestion Window Reduced : ECE 비트를 수신한 송신 프로세스가 전송 윈도우 크기를 줄였음을 알림
> 
> **ECE** : ECN Echo : 네트워크 트래픽이 많을 때 라우터가 송신 프로세스에 명시적으로 혼잡 임을 알림
> 
> **URG** : Urgent Pointer :  긴급 데이터로 순서에 상관없이 먼저 송신됨
> 
> **ACK** : 세그먼트 승인을 알림
> 
> **PSH** : Push : 버퍼링된 데이터를 가능한 빨리 상위 계층에 즉시 전달함을 림
> 
> **RST** : Reset : 연결된 회선에 강제 리셋 요청
> 
> **SYN** : Synchronize : TCP 연결 설정 초기화를 위한 순서 번호의 동기화
> 
> **FIN** : Finish : 데이터 송신의 끝마침을 알림
> 

> **순서 번호, 확인 응답 번호** (Sequence Number, Acknowledgement Number)
> 
> 
> `순서 번호`: 세그먼트의 올바른 순서를 보장하기 위한 번호
> 
> 만약 MSS가 500바이트인데 1900바이트 데이터를 보낸다고 가정하면
> 
> 500, 500, 500, 400의 세그먼트가 순서대로 보내질것임
> 
> 첫 세그먼트의 순서번호는 `초기 순서 번호` 로 무작위 값임 (SYN 플래그 1로 설정)
> 
> 만약 100이라면 뒤에 세그먼트의 순서번호는 600이 됨
> 
> ( = 초기 순서 번호 + 송신한 바이트 수)
> 
> 그러면 맨 마지막 순서 번호는 1600이 된다.
> 
> `확인 응답 번호` : 순서 번호에 대한 응답
> 
> 만약 순서 번호가 600이라면 확인 응답 번호는 601임
> 
> ( = 수신한 순서 번호 + 1)
> 

### TCP 연결 수립

`3-way Handshaking` : 세 단계로 이루어진 TCP의 연결 수립 과정

| 송수신 | 세그먼트 | 주요정보 |
| --- | --- | --- |
| A→B | SYN | A 초기 순서 번호
SYN 1 |
| B→A | SYN + ACK | B 초기 순서 번호
확인 응답 번호
SYN, ACK 1 |
| A→B | ACK | A 다음 순서 번호
확인 응답 번호
ACK 1 |

`액티브 오픈`: 처음 연결 수립 과정

`패시브 오픈` : 처음 연결 수립 요청 다음 보내는 과정

### TCP 오류⋅흐름⋅혼잡 제어

TCP의 신뢰성을 보장하기 위한 과정

- 오류 제어
    
    체크섬이 있긴 하지만 이것만으로는 부족함 (훼손 여부만 나타내기에)
    
    훼손되었으면 폐기해버리니 전송 과정에 문제가 있다는걸 송신한 입장에선 알 수 없음
    
    `RTT` : Round Trip Time : 메세지 전송 뒤 답변 받기까지 걸리는 시간
    
    1. 중복된 ACK 세그먼트를 수신했을 때
        
        ACK를 중복으로 수신하면 이전에 보낸 패킷이 손실되었다는 것을 인지함
        
    2. 타임아웃이 발생했을 때
        
        TCP 세그먼트를 송신하는 호스트는 `재전송 타이머` 값을 유지함
        
        → 호스트가 세그먼트를 전송할 때 마다 활성화 → 시간이 다 지나도 답장이 없으면 타임아웃 → 그러면 답장받아야할 세그먼트를 다시 보냄
        
- 재전송
    
    `ARQ` : Automatic Repeat Request : 문제가 생긴 메세지를 재전송하여 신뢰성을 확보하는 방식 (자동 재전송 요구)
    
    `파이프라이닝` : ACK 세그먼트가 오지 않아도 여러 메세지를 전송하는 기술
    
    `빠른 재전송` : 재전송 타이머가 만료되기 전이라도 세 번의 동일한 ACK 세그먼트가 수신되었다면 해당 세그먼트를 바로 보내는 기능 (성능 높이기)
    
    - Stop-and-Wait ARQ
        
        제대로 전달했음을 확인하기 전까지 새로운 메세지를 보내지 않는 방식
        하지만 네트워크 이용 효율이 낮아짐 → 성능 저하 야기
        (답장을 언제까지 기다려…)
        
    - Go-Back-N ARQ
        
        위 단점을 상쇄 : 각 세그먼트에 대한 답장을 안받아도 여러 세그먼트를 보냄
        파이프라이닝 사용
        얘는 도중에 잘못 전송된 세그먼트가 있으면 해당 세그먼트부터 다시 보냄
        만약 n-1이 유실되었으면 n, n+1이 올바르게 왔어도 폐기함
        
        이러한 확인 응답은 n번만 통신이 잘 되었나? 가 아니라 n번까지 통신이 잘되었나를 확인하는 방식임 → 이를 `누적 확인 응답` 이라고 함
        
    - Selective Repeat ARQ
        
        이름 그대로 선택적으로 재전송 하는 방법
        Go-Back-N ARQ와 다르게 손실된 패킷 다음 제대로 왔으면 폐기를 하지 않음
        그래서 확인 방법도 `개별 확인 응답` 이라고 함
        
        요즘은 거의 Selective 많이 쓰고 이거 지원 안하면 가끔 Go-Back N 씀
        
- 흐름 제어
    
    송신 호스트가 수신 호스트의 처리 속도를 고려하여 통신 속도를 균일하게 유지하는 것
    
    호스트가 한번에 받아서 처리할 수 있는 세그먼트는 한정되어 있어서 파이프라이닝 기반 재전송 기법들이 제대로 돌아가려면 흐름 제어를 해야함
    
    이 처리할 수 있는 크기를 송신지에서 인지를 해야 버퍼 오버 플로우가 나지 않음
    
    `수신 버퍼` : 수신된 세그먼트가 프로세스가 읽기 전에 임시로 저장되는 곳
    
    `버퍼 오버 플로우` : 버퍼의 용량보다 더 많은 세그먼트가 오면 생기는 현상
    
    > Stop-and-Wait ARQ는 흐름 제어가 필요 없음 : 응답까지 기다리니까..
    > 
    
    요즘은 `슬라이딩 윈도우` 만큼은 확인 응답을 받지 않아도 세그먼트를 전송을 가능하도록 함
    
    ![image.png](Network%204%20d87f5adf5a484c8185a4b3e33218517c/image%202.png)
    
- 혼잡 제어
    
    트래픽이 많아 패킷의 처리 속도가 정체되는 네트워크 상황을 혼잡하다고 표현
    
    이전에는 모든 호스트가 라우터에 전송 최대 크기 데이터를 보내면 과부하 발생했음→ 그럼 또 오류검출… → 또 속도 저하 → 반복
    
    `혼잡 윈도우` : 혼잡 없이 전송할 수 있을만한 데이터의 크기
    
    혼잡 제어 알고리즘으로 혼잡 제어를 함
    
    - AIMD (Additive Increase/Multiplicative Decrease)
        
        직역 : 합 증가/ 곱 감소
        
        혼잡이 감지되면 윈도우 % 2, 혼잡하지 않으면 윈도우 + 1
        
    - 느린 시작
        
        혼잡 윈도우를 1부터 시작해 문제 없이 수신된 ACK 세그먼트 1개 당 1씩 증가 시키는 알고리즘
        
        RTT마다 2배씩 지수적으로 증가함 → 혼잡 감지 → 다시 절반 or 혼잡 회피 or 빠른 회복
        
        AIMD보다 윈도우 증가 속도가 빠름
        
    - 혼잡 회피
        
        RTT마다 혼잡 윈도우를 1MSS(Maximum Segment Size)씩 증가 시키는 알고리즘
        
        혼잡 회피 도중 타임아웃이 발생하면 윈도우 사이즈를 1로 줄여버림
        
    - 빠른 회복
        
        3번의 중복된 ACK 세그먼트를 수신하면 느린 시작을 건너 뛰고 혼잡 회피를 수행하는 알고리즘
        
        3번의 중복된 ACK 세그먼트를 수신하면 `빠른 재전송` 과 `빠른 회복` 이 실행됨
        
        빠른 회복 중에 타임아웃이 발생하면 혼잡 윈도우 크기를 1로, 느린 시작 임계치는 혼잡이 감지된 시점의 절반으로 나눠버림
        

### TCP 연결 종료

`4-way handshaking` : 4단계의 TCP 연결 종료 과정

| 송수신 | 세그먼트 | 주요 정보 |
| --- | --- | --- |
| A→B | FIN | FIN 1 (연결 끊는다고 고지) |
| B→A | ACK | 확인 응답 번호
ACK 1 |
| B→A | FIN | FIN 1 (진짜 종료) |
| A→B | ACK | 확인 응답 번호
ACK 1 |

마찬가지로 `액티브 클로즈` A가 한 동작, `패시브 클로즈` B가 한 동작임

### TCP 상태

통신을 유지하기 위해 다양한 상태를 유지함

`상태` : 현재 통신 과정에 있는지 나타내는 정보

TCP를 Stateful Protocol이라고도 함

![정보통신기술용어해설](Network%204%20d87f5adf5a484c8185a4b3e33218517c/image%203.png)

정보통신기술용어해설

TCP 프로토콜이 통신하는 과정임

| 분류 | 상태 |
| --- | --- |
| 1 : 연결 수립 X | CLOSED, LISTEN |
| 2 : 연결 수립 과정 | SYN-SENT, SYN-RECEIVED, ESTABLISHED |
| 3 : 연결 종료 과정 | FIN-WAIT-1, CLOSE_WAIT, FIN-WAIT-2, LAST-ACK, TIME-WAIT, CLOSING |
1. 연결 수립 X : 연결 이전에 호스트들이 유지하는 상태
    
    `CLOSED`  : 아무런 연결이 없는 상태
    
    `LISTEN` : 연결 대기 상태 : 서버는 주로 이 상태고 SYN 세그먼트를 기다리는 상태
    

1. 연결 수립 상태
    
    `SYN-SENT` : 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤 그에 대한 응답인 SNY + ACK 세그먼트를 기다리는 상태 : 연결 요청 보낸 뒤 대기
    
    `SYN-RECEIVED` : 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
    
    `ESTABLISHED` : 연결이 확립되었음을 나타냄 : 데이터 송수신 가능 : 마지막 ACK를 받고 나면 이 상태로 진입
    

1. 연결 종료 상태
    
    `FIN-WAIT-1` : 일반적인 TCP 연결 종료 과정에 있어 첫 단계 FIN 세그먼트로 연결 종료 요청을 보내면 이 상태로 진입
    
    `CLOSE-WATIT` : 종료 요청인 FIN 세그먼트를 받은 패시브 클로즈 호스트가 ACK를 보내고 대기하는 상태
    
    `FIN-WAIT-2` : `FIN-WAIT-1`에서 ACK를 받으면 FIN-WAIT-2 상태가 됨 : 상대의 FIN 세그먼트를 기다리는 상태
    
    `LAST-ACK` : `CLOSE-WAIT` 에서 FIN 세그먼트를 보내고 ACK를 기다리는 상태
    
    `TIME-WAIT` : FIN을 수신 하고 ACK 보내고 진입하는 상태 : 액티브 클로즈 호스트는 일정 시간 기다리고 CLOSE 상태로 전이함
    
    (ACK 세그먼트가 올바르게 전송되었는지 확인하려고 잠깐 대기함)
    
    `CLOSING` : 동시에 연결을 종료할 때 전이되는 상태
    
    서로 FIN을 보내고 ACK 대기중인데, 자신이 보낸 FIN에 대한 ACK를 못받으면 접어드는 상태
    
    이 경우 ACK를 받으면 TIME-WAIT으로 갔다가 종료함
    

## UDP

User Datagram Protocol (Datagram: 독립적인 관계를 지니는 패킷)

UDP : 비연결형 통신  비신뢰성 프로토콜 

아무런 컨트롤이나 재전송도 안해서 Stateless 프로토콜의 일종이다. (Stateful 반대)

![정보통신기술용어해설](Network%204%20d87f5adf5a484c8185a4b3e33218517c/image%204.png)

정보통신기술용어해설

헤드도 비교적 TCP보다 작아 패킷처리가 빠름

TCP는 하나하나 확실히 전송하는데 UDP는 마구마구 던지는 느낌으로 송신한다.

(TCP처럼 세그먼트로 각자의 송수신에 신뢰성을 보장하지 않음)

그 과정에서 패킷이 손실되거나 순서가 바뀔수도 있음 (그냥 체크섬으로 최소한의 오류만 검출함)

신뢰성보다는 연속성이 중요한 실시간 서비스에 자주 사용된다.

소켓을 활용해 IP와 포트 기반으로 데이터를 전송함