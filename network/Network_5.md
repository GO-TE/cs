# Network 5

# 응용 계층

### 도메인 네임

IP에 대응하는 문자열 형태의 호스트 정보

`.` 을 기준으로 계층적으로 분류됨 ex ) www.example.com

- 루트 도메인
    
    도메인 맨 마지막으로 오고 `.` 으로 표현되며 대게 생략함
    
- 최상위 도메인 (TLD)
    
    예시에선 com이 최상위 도메인
    
- 2단계 도메인
    
    예시에선 example이 해당
    
- 3단계 도메인
    
    `www`  << 이거임
    

일반적으로 3단계 ~ 5단계임 위 단계를 다 합치면 `전체 주소 도메인 네임`이라고 함

### 네임 서버

도메인 네임과 IP 주소를 관리하는 서버 (=DNS서버)

도메인 네임이 계층적인 형태를 띄므로 효율적으로 관리하기 위해 네임 서버 또한 계층적인 형태를 띔.

그리고 전 세계 여러군데 여러개 존재해서 이에 대한 관리 체계를 도메인 네임 시스템이라고 함 (DNS)

### 계층적 네임 서버

우리가 URL로 사이트에 접속하는 방법을 보자

IP 주소도 모르는 상태에서 google.com를 URL에 치면 어떤게 일어날까

`로컬 네임 서버` : 클라이언트와 맞닿아 있는 네임 서버

가장 처음으로 얘를 거침 

로컬 네임 서버를 찾을수 있으려면 로컬 네임 서버의 주소를 알고있어야함

일반적으로 ISP에서 할당해주는데, 가끔 로컬 네임 서버 주소가 아닌 `공개 DNS 서버`를 이용할 수도 있음

근데, 로컬 네임 서버가 해당 URL에 대응하는 IP 주소를 모른다 ? 

`루트 네임 서버` : 루트 도메인을 관장하는 네임 서버

를 불러서 질의하게 된다.

그러면 루트 네임 서버가 com을 관리하는 TLD 네임 서버의 주소를 알려준다.

`TLD 네임 서버` : TLD를 관리하는 네임 서버

그러면 www.example.com의 IP 주소를 반환할 수도 있지만 example.com을 관리하는 네임 서버 주소를 리턴할 수도 있음

`책임 네임 서버` : 특정 도메인 영역을 관리하는 네임 서버

더 이상 얘 이상으로 질의하지는 않는다.

www.example.com의 IP 주소를 반환해준다.

### 질의 방법

도메인 네임을 리졸빙하는 과정을 더 자세히 살펴보자.

`재귀적 질의` : 클라이언트 → 로컬 네임 서버 → 루트 네임 서버 → TLD 네임 서버 → 책임 네임 서버 순으로 질의 하는 과정을 반복하여 최종 응답 결과를 역순으로 전달받는 방법 

풀어서 얘기하면, 결과적으로 얻고 싶은 IP 주소가 위 서버들을 모두 거치게 되는 방법

“질의하는 주체가 계속 바뀜”

`반복적 질의` : 클라이언트 → 로컬 네임 서버로 질의 → 로컬 네임 서버가 루트 네임 서버로 질의 → TLD 네임 서버 주소를 받음 → 로컬 네임 서버가 TLD 네임 서버에 질의 → 책임 네임 서버 주소를 받음 → 로컬 네임 서버가 책임 네임 서버에게 질의 → 목표 IP 주소 받기

얘는 묻는 주체가 로컬 네임 서버고, 얘가 계속 질의하는거임

근데 이게 모든 URL을 입력해서 접속한다고 했을 때, 너무 비효율적이다.

호스트가 한둘도 아닐것이고, 그래서 네임 서버들은 DNS 캐시로 IP 주소들을 임시로 저장해둔다.

### URI

`자원` : 네트워크상의 메세지를 통해 주고 받는 대상 (ex HTML, 이미지, 동영상 등…)

`URI` :(Uniform Resource Identifier) 자원을 식별할 수 있는 정보

URI가 URL, URN보다 더 큰 개념

`URL` : (Uniform Resource Locator) 위치를 이용해 자원을 식별할 수 있는 정보

일반적인 URL 표기 방법

```java
foo://www.example.com:8042/over/there?name=ferrey#nose
foo : schema 자원에 접근하는 방법 
www.example.com:8042 : authority 호스트를 특정할 수 있는 정보
/over/there : path 자원이 위치한 경로
?name=ferret : query 특정 자원을 요청할 때 이를 찾을 수 있는 질의
예시에선 name이 ferret인 것을 요청
#nose : fragment 자원의 한 조각을 가리키기 위한 정보
예를 들어 html을 받는다고 할 때, 맨 밑 부분으로 이동시킨다던가. 이런 행위를 하도록 표시할 수 있음
```

`URN` : (Uniform Resource Name) 이름을 이용해 자원을 식별할 수 있는 정보

앞서 URL은 위치 기반으로 자원을 식별 → 하지만 위치는 언제든지 변할 수 있음

그와 반대로 URN은 이름으로 식별하기에 위치와 무관하게 자원을 식별할 수 있다

```java
urn:isbn:0451450523
```

하지만, URN은 URL보다 자주 쓰이진 않는다…

## HTTP

`HTTP` : 응용 계층에서 정보를 주고받는 데 사용하는 프로토콜

### 특징

1. 요청과 응답을 기반으로 동작한다.
    
    클라이언트-서버 구조 기반의 요청-응답 프로토콜
    
    요청 메세지와 응답 메세지의 구조가 다름
    
2. 미디어 독립적이다.
    
    HTTP에서 메세지로 주고받는 자원의 종류를 `미디어 타입`이라고 함
    
    HTTP는 다양한 포멧의 자원을 주고 받을 수 있음
    
    HTTP는 미디어 타입에 특별히 제약을 두지 않고 독립적으로 동작 가능하다
    
3. 상태를 유지하지 않는다.
    
    HTTP는 Stateless 프로토콜이다. 이는 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다를 의미함.
    
    → 곧 클라이언트의 요청은 모두 독립적인 요청으로 간주함
    
    상태를 기억해버리면 서버 입장에서 너무 비효율적이게 되버림
    
    HTTP가 처음 만들어 졌을 때, 중요한 설계 목표는 확장성과 견고성
    
    서버는 하나가 아니라 여러 개가 있을수도 있음
    
    모든 요청을 독립적으로 서버에 종속되지 않게 받는다면 서버를 늘렸을 때, 문제가 되지 않음
    
4. 지속 연결을 지원한다
    
    HTTP는 계속 발전하고 있음. 제일 많이 쓰는 버전은 1.1과 2.0임
    
    기본적으로 HTTP는 TCP상에서 동작하는데, 비연결형 프로토콜이지만 TCP는 연결형 프로토콜임.
    
    초기 HTTP는 요청에 대한 응답을 받으면 연결을 종료하는 방식으로 동작했고, 추가적인 요청-응답은 다시 TCP를 연결해야함 (이러한 방식을 비지속 연결이라고 함)
    
    HTTP 1.1 이상은 `지속 연결` 을 지원하고 있음
    
    TCP 연결상에서 여러개의 응답-요청을 주고 받을수 있는 기술임
    

### HTTP 메세지 구조

크게 START LINE, HEADER, BODY, FOOTER으로 나뉘어져 있음 (HTTP 1.1 기준)

- **START LINE**
    
    HTTP 메세지가 요청인지, 응답인지 나타내는 라인
    
    요청이면 요청라인, 응답이면 상태 라인이 됨
    
    - 요청 라인 = 메서드 (공백) 요청 대상 (공백) HTTP 버전 (줄바꿈)
        
        `메서드` : GET, PUT, POST, DELETE 등 수행할 작업의 종류를 나타냄
        
        `요청 대상` : HTTP 요청을 보낼 서버 자원을 의미 (쿼리가 포함된 URI 경로)
        
        `HTTP 버전` : 말 그대로 사용하는 HTTP 버전
        
    - 상태 라인 = HTTP 버전 (공백) 상태 코드 (공백) 이유 구문 (줄바꿈)
        
        `상태 코드` : 요청에 대한 결과를 나타내는 세자리 정수
        
        `이유 구문` : 상태 코드에 대한 문자열 형태의 설명
        
        ex ) HTTP/1.1 200 OK
        

- HTTP Method
    
    `GET`  특정 자원을 조회할 때 사용 : 응답으로 해당 요청 자원을 return
    
    `HEAD` 헤더만 요청할 때 사용 : 응답 메세지의 본문 없음
    
    `POST` 특정 작업 처리 요청할 때 사용 : 처리할 대상이나 작업 등을 본문에 추가해서 보냄 : 응답 메세지는 요청한 본문과 Location을 포함해서 줌 (자원을 생성하는 작업이라면)
    
    `PUT` 덮어쓰기를 요청하는 메소드 : 요청 자원이 없다면 새롭게 생성함 (완전 대체)
    
    `PATCH` 얘도 수정인데, PUT과 다른 점은 PUT은 요청당한 자원을 완전 대체하면
    
    얘는 수정 요청 안한애들은 고대로 냅둠
    
    `DELETE` 삭제.
    

- HTTP 상태 코드
    
    100번대 : 정보성 상태 코드
    
    200번대 : 성공
    
    300번대 : 리다이렉션 상태 코드
    
    400번대 : 클라이언트 에러 코드
    
    500번대 : 서버 에러 상태 코드
    

- **HEADER**
    
    HTTP 통신에 필요한 부가 정보를 의미
    
    ```java
    GET /example-page HTTP/1.1
    Host: www.example.com
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101
    Firefox/118.0
    Referer: https://www.example.com/request
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    Accept: text/html
    Allow: POST, OPTIONS
    WWW-Authenticate: Basic realm="Acces to enginner site", charset="UTF-8"
    ```
    
    각 헤더는 콜론을 기준으로 헤더 이름과 값으로 구성됨
    
    `Host` 요청을 보낼 호스트를 나타냄. 주로 도메인 네임으로 명시
    
    `User-Agent` 클라이언트 측 프로그램을 나타냄
    
    운영체제, 브라우저 종류 버전, 렌더링 엔진 등 이걸로 뭐로 접속했는지 유추함
    
    `Referer` 클라이언트가 요청을 보낼 때 머물렀던 URL이 명시됨
    
    `Authorization` 인증 정보 : 인증 타입과 정보가 차례대로 명시됨
    
    인코딩 방법에 따라 타입이 나뉘고, 정보에는 해당 방법으로 인코딩한 데이터가 존재
    
    `Server` 요청을 처리하는 서버측 소프트웨어 관련된 정보를 명시
    
    `Allow` 클라이언트에게 허용된 HTTP 메소드 목록을 알려주기 위함
    
    목록에 없는 메소드를 요청하면 `405 Method Not Allowed` 의 상태코드를 반환
    
    `Retry-After` `503 Service Unvailable` 의 상태 코드를 받았을 때 같이 쓰임
    
    현재 요청을 수행할 수 없으니 추후에 가능 할 수도 있음에서 추후가 언제인지 알려줌
    
    `Location` 클라이언트에게 자원의 위치를 알려주는 헤더
    
    `WWW-Authnicate` 요청한 자원에 대해 유효한 인증수단이 없을 때 응답하는 상태코드 `401 Unauthorized` 와 함께 반환되는데, 요청할 때 필요한 인증방식이 뭔지 명시됨. 혹은 더 많은 정보를 포함함
    
    - 요청과 응답 모두 활용되는 헤더
    
    ```java
    Date: Tue, 15 Nov 1994 08:12:31 GMT
    Connection: keep-alive
    Content-Length: 100
    Content-Type: text/html; charset=UTF-8
    Content-Language: ko-KR
    Content-Encoding: gzip
    ```
    
    `Date` 메세지가 생성된 날짜와 시각
    
    `Connection` 요청과 응답 간 연결 방식을 설정하는 헤더 (지속 연결인지? 아니면 종료인지? close)
    
    `Content-Length` 본문의 바이트 단위 크기
    
    `Content-Type` 본문에 사용된 미디어 타입
    
    `Content-Language` 사용된 자연어태그 (언어-나라) : en-US (미국 영어를 알림)
    
    `Content-Encoding` 본문을 압축하거나 변환한 방식을 명시함
    

Authorization 인증 수행 과정

1. 인증되지 않은 클라이언트가 서버에 GET 요청
2. 서버가 응답으로 401 상태코드와 WWW-Authenticate 헤더를 통해 인증 방식을 알림
3. 클라이언트는 사용자로부터 인증정보를 전달받음
4. 클라이언트는 받은 값을 인코딩하여 다시 전송
5. 인증정보 확인
6. 유효하면 → 200,  무효하면 → 401 응답

### 캐시

불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 사본을 임시로 저장하는 기술

저장되는 위치는 클라이언트에 되기도 하고, 서버와 클라 사이의 미들서버에 저장되기도함

예를 들어, [naver.com](http://naver.com)을 한번 접속하면 naver 홈페이지가 뜰텐데, 여러번 접속을 시도하면 할때마다 그 여러가지 링크와 배너 이미지를 계속 요청하고 보내야하는 경우가 생김

근데 이걸 미리 저장해두면 통신과정을 스킵할 수 있어서 좀 더 빠른 로딩이 되지않을까요?

근데 여기서 원본이 아닌 사본을 저장하니, 원본 데이터가 변경되는 사항도 고려해야함

캐시 데이터에는 원본 데이터와 얼마나 유사한지 캐시 신선도라고 표현함

이를 보증하는 대표적인 방법은 캐시 데이터의 유효기간을 주어 기간이 만료된다면 원본 데이터를 다시 요청하는 방식으로 캐시를 업데이트함

다른 방법으론 엔티티 태그(Etag)를 사용하는 방법

엔티티 태그 : 자원의 버전을 식별하기 위한 정보

서버에서 자원이 변경될 때 버전 값인 Etag값이 변경됨

클라이언트가 신선도를 검사할 때 서버에 요청으로 `If-None-Match`라는 헤더로 etag값을 보내면 이에 대한 응답으로 바뀐게 있는지 없는지 검사할 수 있음

→ 기한을 같이 보내고 이후에 바뀐게 있는지 서버에선 확인함

유효기간의 경우는 `If-Modified-Since`라는 헤더로 검사함

→ 태그의 값이 유효한지 검사 후 요청에 대한 응답을 보냄

검사할 때 서버 입장에서 겪는 상황 + 대처

1. 요청 받은 자원이 동일 (304 상태 코드 응답)
2. 요청 받은 자원이 변경 (200 상태코드와 새로운 자원을 반환)
3. 요청 받은 자원이 삭제됨 (404 상태코드 반환)

### 쿠키

서버에서 생성되어 클라이언트 측에 저장되는 데이터로, 상태를 저장하지 않는 HTTP의 특성을 보완하기 위한 수단

key, value의 형태를 띄고 있고 적용범위, 만료 기간 등 여러 메타 데이터를 가질 수 있음

어디에 쓰이느냐?

네이버나 여러 웹서비스에서 로그인할 때 로그인 상태 유지를 보셨나요?

HTTP는 stateless 프로토콜인데 로그인 상태를 어떻게 유지하도록 하느냐..

우리는 이걸 쿠키로 가능하게합니당

동작방식

일단 HTTP 헤더에 포함되어 쿠키가 주고 받아집니다.

1. 서버에서 `Set-Cookie` 라는 헤더로 쿠키를 전달함
    
    한번에 여러개도 보낼 수 있음 `Set-Cookie: name=value; attribution` 
    
2. 이제 이걸 받은 클라이언트는 쿠키를 저장함.
    
    그리고 서버에 요청을 보낼 때 `Cookie` 헤더에 첨부해서 보냄
    
    `Cookie: name=value; attribution` 
    

근데 쿠키를 전달받은 도메인에서만 받은 쿠키를 써야하겠죠????

그리고 쿠키는 유효기간이 있어 지나면 삭제되어 다시 전달이 되지 않습니당