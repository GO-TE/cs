# Network 5

# 응용 계층

### 도메인 네임

IP에 대응하는 문자열 형태의 호스트 정보

`.` 을 기준으로 계층적으로 분류됨 ex ) www.example.com

- 루트 도메인
    
    도메인 맨 마지막으로 오고 `.` 으로 표현되며 대게 생략함
    
- 최상위 도메인 (TLD)
    
    예시에선 com이 최상위 도메인
    
- 2단계 도메인
    
    예시에선 example이 해당
    
- 3단계 도메인
    
    `www`  << 이거임
    

일반적으로 3단계 ~ 5단계임 위 단계를 다 합치면 `전체 주소 도메인 네임`이라고 함

### 네임 서버

도메인 네임과 IP 주소를 관리하는 서버 (=DNS서버)

도메인 네임이 계층적인 형태를 띄므로 효율적으로 관리하기 위해 네임 서버 또한 계층적인 형태를 띔.

그리고 전 세계 여러군데 여러개 존재해서 이에 대한 관리 체계를 도메인 네임 시스템이라고 함 (DNS)

### 계층적 네임 서버

우리가 URL로 사이트에 접속하는 방법을 보자

IP 주소도 모르는 상태에서 google.com를 URL에 치면 어떤게 일어날까

`로컬 네임 서버` : 클라이언트와 맞닿아 있는 네임 서버

가장 처음으로 얘를 거침 

로컬 네임 서버를 찾을수 있으려면 로컬 네임 서버의 주소를 알고있어야함

일반적으로 ISP에서 할당해주는데, 가끔 로컬 네임 서버 주소가 아닌 `공개 DNS 서버`를 이용할 수도 있음

근데, 로컬 네임 서버가 해당 URL에 대응하는 IP 주소를 모른다 ? 

`루트 네임 서버` : 루트 도메인을 관장하는 네임 서버

를 불러서 질의하게 된다.

그러면 루트 네임 서버가 com을 관리하는 TLD 네임 서버의 주소를 알려준다.

`TLD 네임 서버` : TLD를 관리하는 네임 서버

그러면 www.example.com의 IP 주소를 반환할 수도 있지만 example.com을 관리하는 네임 서버 주소를 리턴할 수도 있음

`책임 네임 서버` : 특정 도메인 영역을 관리하는 네임 서버

더 이상 얘 이상으로 질의하지는 않는다.

www.example.com의 IP 주소를 반환해준다.

### 질의 방법

도메인 네임을 리졸빙하는 과정을 더 자세히 살펴보자.

`재귀적 질의` : 클라이언트 → 로컬 네임 서버 → 루트 네임 서버 → TLD 네임 서버 → 책임 네임 서버 순으로 질의 하는 과정을 반복하여 최종 응답 결과를 역순으로 전달받는 방법 

풀어서 얘기하면, 결과적으로 얻고 싶은 IP 주소가 위 서버들을 모두 거치게 되는 방법

“질의하는 주체가 계속 바뀜”

`반복적 질의` : 클라이언트 → 로컬 네임 서버로 질의 → 로컬 네임 서버가 루트 네임 서버로 질의 → TLD 네임 서버 주소를 받음 → 로컬 네임 서버가 TLD 네임 서버에 질의 → 책임 네임 서버 주소를 받음 → 로컬 네임 서버가 책임 네임 서버에게 질의 → 목표 IP 주소 받기

얘는 묻는 주체가 로컬 네임 서버고, 얘가 계속 질의하는거임

근데 이게 모든 URL을 입력해서 접속한다고 했을 때, 너무 비효율적이다.

호스트가 한둘도 아닐것이고, 그래서 네임 서버들은 DNS 캐시로 IP 주소들을 임시로 저장해둔다.

### URI

`자원` : 네트워크상의 메세지를 통해 주고 받는 대상 (ex HTML, 이미지, 동영상 등…)

`URI` :(Uniform Resource Identifier) 자원을 식별할 수 있는 정보

URI가 URL, URN보다 더 큰 개념

`URL` : (Uniform Resource Locator) 위치를 이용해 자원을 식별할 수 있는 정보

일반적인 URL 표기 방법

```java
foo://www.example.com:8042/over/there?name=ferrey#nose
foo : schema 자원에 접근하는 방법 
www.example.com:8042 : authority 호스트를 특정할 수 있는 정보
/over/there : path 자원이 위치한 경로
?name=ferret : query 특정 자원을 요청할 때 이를 찾을 수 있는 질의
예시에선 name이 ferret인 것을 요청
#nose : fragment 자원의 한 조각을 가리키기 위한 정보
예를 들어 html을 받는다고 할 때, 맨 밑 부분으로 이동시킨다던가. 이런 행위를 하도록 표시할 수 있음
```

`URN` : (Uniform Resource Name) 이름을 이용해 자원을 식별할 수 있는 정보

앞서 URL은 위치 기반으로 자원을 식별 → 하지만 위치는 언제든지 변할 수 있음

그와 반대로 URN은 이름으로 식별하기에 위치와 무관하게 자원을 식별할 수 있다

```java
urn:isbn:0451450523
```

하지만, URN은 URL보다 자주 쓰이진 않는다…

## HTTP

`HTTP` : 응용 계층에서 정보를 주고받는 데 사용하는 프로토콜

### 특징

1. 요청과 응답을 기반으로 동작한다.
    
    클라이언트-서버 구조 기반의 요청-응답 프로토콜
    
    요청 메세지와 응답 메세지의 구조가 다름
    
2. 미디어 독립적이다.
    
    HTTP에서 메세지로 주고받는 자원의 종류를 `미디어 타입`이라고 함
    
    HTTP는 다양한 포멧의 자원을 주고 받을 수 있음
    
    HTTP는 미디어 타입에 특별히 제약을 두지 않고 독립적으로 동작 가능하다
    
3. 상태를 유지하지 않는다.
    
    HTTP는 Stateless 프로토콜이다. 이는 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다를 의미함.
    
    → 곧 클라이언트의 요청은 모두 독립적인 요청으로 간주함
    
    상태를 기억해버리면 서버 입장에서 너무 비효율적이게 되버림
    
    HTTP가 처음 만들어 졌을 때, 중요한 설계 목표는 확장성과 견고성
    
    서버는 하나가 아니라 여러 개가 있을수도 있음
    
    모든 요청을 독립적으로 서버에 종속되지 않게 받는다면 서버를 늘렸을 때, 문제가 되지 않음
    
4. 지속 연결을 지원한다
    
    HTTP는 계속 발전하고 있음. 제일 많이 쓰는 버전은 1.1과 2.0임
    
    기본적으로 HTTP는 TCP상에서 동작하는데, 비연결형 프로토콜이지만 TCP는 연결형 프로토콜임.
    
    초기 HTTP는 요청에 대한 응답을 받으면 연결을 종료하는 방식으로 동작했고, 추가적인 요청-응답은 다시 TCP를 연결해야함 (이러한 방식을 비지속 연결이라고 함)
    
    HTTP 1.1 이상은 `지속 연결` 을 지원하고 있음
    
    TCP 연결상에서 여러개의 응답-요청을 주고 받을수 있는 기술임
    

### HTTP 메세지 구조

크게 START LINE, HEADER, BODY, FOOTER으로 나뉘어져 있음 (HTTP 1.1 기준)

- **START LINE**
    
    HTTP 메세지가 요청인지, 응답인지 나타내는 라인
    
    요청이면 요청라인, 응답이면 상태 라인이 됨
    
    - 요청 라인 = 메서드 (공백) 요청 대상 (공백) HTTP 버전 (줄바꿈)
        
        `메서드` : GET, PUT, POST, DELETE 등 수행할 작업의 종류를 나타냄
        
        `요청 대상` : HTTP 요청을 보낼 서버 자원을 의미 (쿼리가 포함된 URI 경로)
        
        `HTTP 버전` : 말 그대로 사용하는 HTTP 버전
        
    - 상태 라인 = HTTP 버전 (공백) 상태 코드 (공백) 이유 구문 (줄바꿈)
        
        `상태 코드` : 요청에 대한 결과를 나타내는 세자리 정수
        
        `이유 구문` : 상태 코드에 대한 문자열 형태의 설명
        
        ex ) HTTP/1.1 200 OK
        

- HTTP Method
    
    `GET`  특정 자원을 조회할 때 사용 : 응답으로 해당 요청 자원을 return
    
    `HEAD` 헤더만 요청할 때 사용 : 응답 메세지의 본문 없음
    
    `POST` 특정 작업 처리 요청할 때 사용 : 처리할 대상이나 작업 등을 본문에 추가해서 보냄 : 응답 메세지는 요청한 본문과 Location을 포함해서 줌 (자원을 생성하는 작업이라면)
    
    `PUT` 덮어쓰기를 요청하는 메소드 : 요청 자원이 없다면 새롭게 생성함 (완전 대체)
    
    `PATCH` 얘도 수정인데, PUT과 다른 점은 PUT은 요청당한 자원을 완전 대체하면
    
    얘는 수정 요청 안한애들은 고대로 냅둠
    
    `DELETE` 삭제.
    

- HTTP 상태 코드
    
    100번대 : 정보성 상태 코드
    
    200번대 : 성공
    
    300번대 : 리다이렉션 상태 코드
    
    400번대 : 클라이언트 에러 코드
    
    500번대 : 서버 에러 상태 코드
    

- **HEADER**
    
    HTTP 통신에 필요한 부가 정보를 의미
    
    ```java
    GET /example-page HTTP/1.1
    Host: www.example.com
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101
    Firefox/118.0
    Referer: https://www.example.com/request
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    Accept: text/html
    ```
    
    각 헤더는 콜론을 기준으로 헤더 이름과 값으로 구성됨
    
    `Host` 요청을 보낼 호스트를 나타냄. 주로 도메인 네임으로 명시
    
    `User-Agent` 클라이언트 측 프로그램을 나타냄
    
    운영체제, 브라우저 종류 버전, 렌더링 엔진 등 이걸로 뭐로 접속했는지 유추함
    
    `Referer` 클라이언트가 요청을 보낼 때 머물렀던 URL이 명시됨
    
    `Authorization` 인증 정보 : 인증 타입과 정보가 차례대로 명시됨
    
    인코딩 방법에 따라 타입이 나뉘고, 정보에는 해당 방법으로 인코딩한 데이터가 존재
    
    `Server` 요청을 처리하는 서버측 소프트웨어 관련된 정보를 명시